{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/node_modules/three/examples/jsm/loaders/STLLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tVector3,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * A loader for the STL format, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files. The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n * - Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n * - There is perhaps some question as to how valid it is to always assume little-endian-ness.\n * - ASCII decoding assumes file is UTF-8.\n *\n * ```js\n * const loader = new STLLoader();\n * const geometry = await loader.loadAsync( './models/stl/slotted_disk.stl' )\n * scene.add( new THREE.Mesh( geometry ) );\n * ```\n * For binary STLs geometry might contain colors for vertices. To use it:\n * ```js\n * // use the same code to load STL as above\n * if ( geometry.hasColors ) {\n * \tmaterial = new THREE.MeshPhongMaterial( { opacity: geometry.alpha, vertexColors: true } );\n * }\n * const mesh = new THREE.Mesh( geometry, material );\n * ```\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * ```js\n * const materials = [];\n * const nGeometryGroups = geometry.groups.length;\n *\n * for ( let i = 0; i < nGeometryGroups; i ++ ) {\n * \tconst material = new THREE.MeshPhongMaterial( { color: colorMap[ i ], wireframe: false } );\n * \tmaterials.push( material );\n * }\n *\n * const mesh = new THREE.Mesh(geometry, materials);\n * ```\n *\n * @augments Loader\n * @three_import import { STLLoader } from 'three/addons/loaders/STLLoader.js';\n */\nclass STLLoader extends Loader {\n\n\t/**\n\t * Constructs a new STL loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded STL asset\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given STL data and returns the resulting geometry.\n\t *\n\t * @param {ArrayBuffer} data - The raw STL data as an array buffer.\n\t * @return {BufferGeometry} The parsed geometry.\n\t */\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tconst color = new Color();\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolor.setRGB( r, g, b, SRGBColorSpace );\n\n\t\t\t\t\t\tcolors[ componentIdx ] = color.r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = color.g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = color.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tconst patternName = /solid\\s(.+)/;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst groupNames = [];\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\tconst name = ( result = patternName.exec( solid ) ) !== null ? result[ 1 ] : '';\n\t\t\t\tgroupNames.push( name );\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.userData.groupNames = groupNames;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn new TextDecoder().decode( buffer );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\nexport { STLLoader };\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}